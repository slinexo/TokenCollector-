repeat 
    task.wait() 
until 
    game:IsLoaded() 
    and game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") 
    and game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.LoadingMessage.Visible == false

-- // Services
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- // Fluent UI
local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()

-- // ScriptHive table
local ScriptHive = {}

-- Provide 'vitaly' so the tween function can reference 'vitaly.humanoidrootpart()'
-- without changing the function body itself.
local vitaly = ScriptHive

-------------- // FUNCTIONS // --------------

ScriptHive["humanoidrootpart"] = function()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local noclipConnection = nil
ScriptHive["noclip"] = function(state)
    if state then
        if not noclipConnection then
            noclipConnection = RunService.Stepped:Connect(function()
                local char = LocalPlayer.Character
                if char then
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
    end
end

-------------- // TWEENING // --------------

-- We won't do an immediate tween per token. Instead, we keep a loop below
-- that picks the closest token from recognizedTokens and goes there.

ScriptHive["tween"] = function(speed, pos)
    if ScriptHive.humanoidrootpart() then
        if typeof(pos) == "CFrame" then pos = pos.p end
        local speed = (vitaly.humanoidrootpart().Position - pos).Magnitude / speed
        game:GetService("TweenService"):Create(
            vitaly.humanoidrootpart(),
            TweenInfo.new(speed, Enum.EasingStyle.Linear),
            {CFrame = CFrame.new(pos)}
        ):Play()
        task.wait(speed)
    end
end

-------------- // MAIN // --------------

ScriptHive["notify"] = function(title, description, duration)
    pcall(function()
        game.StarterGui:SetCore("SendNotification", {
            Title = title;
            Text = description;
            Duration = duration;
        })
    end)
end

-- // Fluent Window
local Window = Library:CreateWindow({
    Title = "ScriptHive",
    SubTitle = "Token Collector",
    TabWidth = 160,
    Size = UDim2.fromOffset(560, 240),
    Acrylic = true,
    Theme = "Dark"
})

-- // Global table for user config
getgenv().ScriptHive = {
    toggles = {
        Activate = false,
    },
    tokens = {
        names = {
            "Honey",
            "Royal Jelly",
            "Star Jelly"
            "Snowflake",
            "Strawberry",
            "Blueberry",
            "Pineapple",
            "Sunflower Seed"
        },
        decals = {
            "rbxassetid://1472135114",
            "rbxassetid://1471882621",
            "rbxassetid://2319943273",
            "rbxassetid://6087969886",
            "rbxassetid://1952740625",
            "rbxassetid://2028453814",
            "rbxassetid://1952796050",
            "rbxassetid://1952682426"
        }
    },
    selectedDecals = {},
    -- We'll store our tween speed here (updated by the slider).
    tweenspeed = 64
}

-- We'll store newly recognized tokens in a dictionary:
local recognizedTokens = setmetatable({}, {__mode = "k"})

local CollectiblesConnection

-- When collecting, we don't want to start multiple loops
local isCollecting = false

-- Finds the closest valid token in recognizedTokens
local function getClosestToken()
    local hrp = ScriptHive.humanoidrootpart()
    if not hrp then return nil end

    local closestDist = math.huge
    local closestChild = nil

    for child in pairs(recognizedTokens) do
        -- Make sure it's still in workspace (not destroyed)
        -- and has the frontDecal
        if child and child.Parent then
            local frontDecal = child:FindFirstChild("FrontDecal")
            if frontDecal and frontDecal:IsA("Decal") then
                local distance = (hrp.Position - child.Position).Magnitude
                if distance < closestDist then
                    closestDist = distance
                    closestChild = child
                end
            else
                -- If no decal or child is invalid, remove it
                recognizedTokens[child] = nil
            end
        else
            -- Child gone from workspace
            recognizedTokens[child] = nil
        end
    end

    return closestChild
end

-- Loops through recognizedTokens, always going to the nearest
local function CollectTokensLoop()
    isCollecting = true
    while true do
        local child = getClosestToken()
        if not child then 
            -- No tokens left
            break 
        end

        -- Attempt the actual tween
        if child.Parent then
            ScriptHive.noclip(true)
            ScriptHive.tween(getgenv().ScriptHive.tweenspeed, child.Position)
            ScriptHive.noclip(false)
        end

        -- Remove from recognized tokens after we move
        recognizedTokens[child] = nil
    end
    isCollecting = false
end

-- Call this whenever a new token is added to recognizedTokens
local function TryCollectTokens()
    if not isCollecting then
        CollectTokensLoop()
    end
end

-- (Optional) function that scans existing tokens once
local function ScanForTokens()
    local collectiblesFolder = workspace:FindFirstChild("Collectibles")
    if not collectiblesFolder then return end

    for _, child in ipairs(collectiblesFolder:GetChildren()) do
        if not recognizedTokens[child] then
            local frontDecal = child:FindFirstChild("FrontDecal")
            if frontDecal and frontDecal:IsA("Decal") then
                local itemTexture = frontDecal.Texture
                if table.find(getgenv().ScriptHive.selectedDecals, itemTexture) then
                    recognizedTokens[child] = true
                end
            end
        end
    end
    -- After scanning, try collecting in the order of closeness
    TryCollectTokens()
end

local function MainFunction()
    if CollectiblesConnection then
        CollectiblesConnection:Disconnect()
        CollectiblesConnection = nil
    end

    local collectiblesFolder = workspace:FindFirstChild("Collectibles")
    if not collectiblesFolder then
        ScriptHive.notify("ScriptHive", "No Collectibles folder found!", 5)
        return
    end

    CollectiblesConnection = collectiblesFolder.ChildAdded:Connect(function(child)
        task.wait(0.1)
        local frontDecal = child:FindFirstChild("FrontDecal")
        if frontDecal and frontDecal:IsA("Decal") then
            local itemTexture = frontDecal.Texture
            if table.find(getgenv().ScriptHive.selectedDecals, itemTexture) then
                recognizedTokens[child] = true
                -- We added a token, so try collecting the nearest
                TryCollectTokens()
            end
        end
    end)

    -- If you want to also collect existing tokens, uncomment:
    -- ScanForTokens()
end

-------------- // FLUENT UI // --------------

local Tabs = {
    Main = Window:CreateTab({ Title = "Main", Icon = "lucide-joystick" }),
    Settings = Window:CreateTab({ Title = "Settings", Icon = "lucide-cog" })
}

Tabs.Main:CreateToggle("Activate", {
    Title = "Activate",
    Default = getgenv().ScriptHive.toggles.Activate,
    Callback = function(state)
        getgenv().ScriptHive.toggles.Activate = state
        if state then
            MainFunction()
        else
            table.clear(recognizedTokens)
            if CollectiblesConnection then
                CollectiblesConnection:Disconnect()
                CollectiblesConnection = nil
            end
        end
    end
})

Tabs.Settings:AddSlider("Tween Speed", {
    Title = "Tween Speed",
    Min = 16,
    Max = 256,
    Rounding = 1,
    Default = getgenv().ScriptHive.tweenspeed,
    Callback = function(value)
        getgenv().ScriptHive.tweenspeed = value
        print("New Tween Speed:", value)
    end
})

Tabs.Main:CreateDropdown("Dropdown", {
    Title = "Tokens",
    Values = getgenv().ScriptHive.tokens.names,
    Multi = true,
    Default = {},
    Callback = function(selectedTable)
        table.clear(getgenv().ScriptHive.selectedDecals)
        
        for name, isSelected in pairs(selectedTable) do
            if isSelected then
                local index = table.find(getgenv().ScriptHive.tokens.names, name)
                if index then
                    local decal = getgenv().ScriptHive.tokens.decals[index]
                    print(("Selected: %s => %s"):format(name, decal))
                    table.insert(getgenv().ScriptHive.selectedDecals, decal)
                end
            end
        end

        if getgenv().ScriptHive.toggles.Activate then
            table.clear(recognizedTokens)
            -- If you also want to gather existing tokens in the new selection,
            -- uncomment this:
            -- ScanForTokens()
        end
    end
})
